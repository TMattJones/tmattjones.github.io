[{'title': '{W}ho guards the guards? {F}ormal {V}alidation of the {A}RM v8-{M} Architecture {S}pecification', 'author': 'Alastair Reid', 'affiliation': 'ARM Ltd', 'abstract': 'Software and hardware are increasingly being formally verified\nagainst specifications, but how can we verify the\nspecifications themselves? This talk explores what it means to\nformally verify a specification. We solve three challenges: (1)\nHow to create a secondary, higher-level specification that can\nbe effectively reviewed by processor designers who are not\nexperts in formal verification; (2) How to avoid common-mode\nfailures between the specifications; and (3) How to\nautomatically verify the two specifications against each other.\n\nOne of the most important specifications for software\nverification is the processor specification since it de nes the\nbehaviour of machine code and of hardware protection features\nused by operating systems. We demonstrate our approach on ARM\\textquotesingle s\nv8-M Processor Specification, which is intended to improve the\nsecurity of Internet of Things devices. Thus, we focus on\nestablishing the security guarantees the architecture is\nintended to provide. Despite the fact that the ARM v8-M\nspecification had previously been extensively tested, we found\ntwelve bugs (including two security bugs) that have all been\nfixed by ARM.', 'journal': 'PACMPL', 'volume': '1', 'number': 'OOPSLA', 'pages': '88:1--88:24', 'year': '2017', 'month': 'October', 'day': '22\\textendash 27', 'doi': '10.1145/3133912', 'ar_shortname': 'OOPSLA 17', 'location': 'Vancouver, BC, Canada', 'numpages': '24', 'publisher': 'ACM', 'address': 'New York, NY, USA', 'ENTRYTYPE': 'inproceedings', 'ID': 'conf/oopsla/Reid17', 'file': 'oopsla2017-whoguardstheguards.pdf', 'slides': 'oopsla2017-whoguardstheguards-slides.pdf', 'ar_file': 'OOPSLA_17', 'ar_title': 'Who guards the guards? Formal Validation of the ARM v8-M Architecture Specification'}, {'title': '{T}he {A}RM {S}calable {V}ector {E}xtension', 'author': 'Nigel Stephens\nand\nStuart Biles\nand\nMatthias Boettcher\nand\nJacob Eapen\nand\nMbou Eyole\nand\nGiacomo Gabrielli\nand\nMatt Horsnell\nand\nGrigorios Magklis\nand\nAlejandro Martinez\nand\nNathanael Premillieu\nand\nAlastair Reid\nand\nAlejandro Rico\nand\nPaul Walker', 'affiliation': 'ARM Ltd', 'abstract': 'In this paper we describe the ARM Scalable Vector Extension\n(SVE). Several goals guided the design of the architecture. First was\nthe need to extend the vector processing capability associated with\nthe ARM AArch64 execution state to better address the compute\nrequirements in domains such as high performance computing (HPC), data\nanalytics, computer vision and machine learning. Second was the desire\nto introduce an extension that can scale across multiple\nimplementations, both now and into the future, allowing CPU designers\nto choose the vector length most suitable for their power, performance\nand area targets. Finally, the architecture should avoid imposing a\nsoftware development cost as the vector length changes and where\npossible reduce it by improving the reach of compiler\nauto-vectorization technologies.\n\nWe believe SVE achieves these goals. It allows implementations to\nchoose a vector register length between 128 and 2048 bits. It supports\na vector length agnostic programming model which allows code to run\nand scale automatically across all vector lengths without\nrecompilation. Finally, it introduces several innovative features that\nbegin to overcome some of the traditional barriers to\nauto-vectorization.', 'journal': 'IEEE Micro', 'month': 'March', 'year': '2017', 'volume': '37', 'number': '2', 'pages': '26--39', 'doi': '10.1109/MM.2017.35', 'ar_shortname': 'IEEE Micro', 'ENTRYTYPE': 'article', 'ID': 'journal/micro/sve2017', 'file': 'sve-ieee-micro-2017.pdf', 'ar_file': 'IEEE_Micro', 'ar_title': 'The ARM Scalable Vector Extension'}, {'title': '{T}rustworthy {S}pecifications of {A{R}M} {v8-A} and {v8-M}\n{S}ystem {L}evel {A}rchitecture', 'author': 'Alastair Reid', 'affiliation': 'ARM Ltd', 'abstract': 'Processor specifications are of critical importance for verifying programs, compilers, operating systems/hypervisors, and, of course, for verifying\nmicroprocessors themselves.  But to be useful, the scope of these\nspecifications must be sufficient for the task, the specification must be\napplicable to processors of interest and the specification must be trustworthy.\n\nThis paper describes a 5 year project to change ARM\\textquotesingle s existing architecture\nspecification process so that machine-readable, executable specifications can\nbe automatically generated from the same materials used to generate ARM\\textquotesingle s\nconventional architecture documentation.  We have developed executable\nspecifications of both ARM\\textquotesingle s A-class and M-class processor architectures that\nare complete enough and trustworthy enough that we have used them to formally\nverify ARM processors using bounded model checking.  In particular, our\nspecifications include the semantics of the most security sensitive parts of\nthe processor: the memory and register protection mechanisms and the exception\nmechanisms that trigger transitions between different modes.  Most importantly, we have applied a diverse set of methods including ARM\\textquotesingle s internal processor\ntest suites to improve our trust in the specification using many other\nexpressions of the architectural specification such as ARM\\textquotesingle s simulators, testsuites and processors to defend against common-mode failure.  In the\nprocess, we have also found bugs in all those artifacts: testing specifications\nis very much a two-way street.\n\nWhile there have been previous specifications of ARM processors, their scope\nhas excluded the system architecture, their applicability has excluded newer\nprocessors and M-class, and their trustworthiness has not been established as\nthoroughly.\n\nOur focus has been on enabling the formal verification of ARM processors but, recognising the value of this specification for verifying software, we are\ncurrently preparing a public release of the machine-readable specification.', 'booktitle': 'Proceedings of Formal Methods in Computer-Aided Design\n({FMCAD} 2016)', 'location': 'Mountain View, CA, USA', 'pages': '161-168', 'month': 'October', 'year': '2016', 'isbn': '978-0-9835678-6-8', 'ar_shortname': 'FMCAD 16', 'link': 'https://alastairreid.github.io/papers/fmcad2016-trustworthy.pdf', 'ENTRYTYPE': 'inproceedings', 'ID': 'conf/fmcad/Reid16', 'file': 'fmcad2016-trustworthy.pdf', 'slides': 'fmcad2016-trustworthy-slides.pdf', 'ar_file': 'FMCAD_16', 'ar_title': 'Trustworthy Specifications of ARM v8-A and v8-M System Level Architecture'}, {'title': '{E}nd-to-{E}nd {V}erification of {A{R}M} {P}rocessors with {I{S}A-{F}ormal}', 'booktitle': 'Proceedings of the 2016 International Conference on Computer Aided Verification (CAV\\textquotesingle 16)', 'affiliation': 'ARM Ltd', 'abstract': 'Despite 20+ years of research on processor verification, it remains hard to use\nformal verification techniques in commercial processor development.  There are\ntwo significant factors: scaling issues and return on investment.  The\nscaling issues include the size of modern processor specifications, the\nsize/complexity of processor designs, the size of design/verification teams and\nthe (non)availability of enough formal verification experts.  The return on\ninvestment issues include the need to start catching bugs early in development, the need to continue catching bugs throughout development, and the need to be\nable to reuse verification IP, tools and techniques across a wide range of\ndesign styles.\n\nThis paper describes how ARM has overcome these issues in our Instruction Set\nArchitecture Formal Verification framework \\textasciigrave \\textasciigrave ISA-Formal.\\textquotesingle \\textquotesingle  This is an\nend-to-end framework to detect bugs in the datapath, pipeline control and\nforwarding/stall logic of processors.  A key part of making the approach scale\nis use of a mechanical translation of ARM\\textquotesingle s Architecture Reference Manuals to\nVerilog allowing the use of commercial model-checkers.  ISA-Formal has proven\nespecially effective at finding micro-architecture specific bugs involving\ncomplex sequences of instructions.\n\nAn essential feature of our work is that it is able to scale all the way from\nsimple 3-stage microcontrollers, through superscalar in-order processors up to\nout-of-order processors.  We have applied this method to 8 different ARM\nprocessors spanning all stages of development up to release.  In all\nprocessors, this has found bugs that would have been hard for conventional\nsimulation-based verification to find and ISA-Formal is now a key part of ARM\\textquotesingle s\nformal verification strategy.\n\nTo the best of our knowledge, this is the most broadly applicable formal\nverification technique for verifying processor pipeline control in mainstream\ncommercial use.', 'acceptance': '28', 'editor': 'S. Chaudhuri and A. Farzan', 'series': 'Lecture Notes in Computer Science', 'volume': '9780', 'pages': '42-58', 'publisher': 'Springer Verlag', 'month': 'July', 'year': '2016', 'author': 'Alastair Reid and Rick Chen and Anastasios Deligiannis and\nDavid Gilday and David Hoyes and Will Keen and Ashan Pathirane and\nOwen Shepherd and Peter Vrabel and Ali Zaidi', 'journal': 'CAV 2016, Part II, Lecture Notes in Computer Science', 'location': 'Toronto, Canada', 'number': '9780', 'doi': '10.1007/978-3-319-41540-6\\_3', 'ar_shortname': 'CAV 16', 'isbn': '978-3-319-41539-0', 'ENTRYTYPE': 'inproceedings', 'ID': 'conf/cav/Reid16', 'file': 'cav2016_isa_formal.pdf', 'slides': 'ISA-Formal-CAV2016.pdf', 'ar_file': 'CAV_16', 'ar_title': 'End-to-End Verification of ARM Processors with ISA-Formal'}, {'author': 'Matthias Boettcher and\nBashir M. Al{-}Hashimi and\nMbou Eyole and\nGiacomo Gabrielli and\nAlastair Reid', 'affiliation': 'ARM Ltd and University of Southampton', 'abstract': 'SIMD extensions have gained widespread acceptance in modern\nmicroprocessors as a way to exploit data-level parallelism in\ngeneral-purpose cores. Popular SIMD architectures (e.g., Intel\nSSE/AVX) have evolved by adding support for wider registers and\ndatapaths, and advanced features like indexed memory\naccesses, per-lane predication and inter-lane instructions, at\nthe cost of additional silicon area and design complexity.\n\nThis paper evaluates the performance impact of such advanced\nfeatures on a set of workloads considered hard to vectorize for\ntraditional SIMD architectures. Their sensitivity to the most\nrelevant design parameters (e.g. register/datapath width and L1\ndata cache configuration) is quantified and discussed.\n\nWe developed an ARMv7 NEON based ISA extension (ARGON), augmented a cycle accurate simulation framework for it, and\nderived a set of benchmarks from the Berkeley dwarfs. Our\nanalyses demonstrate how ARGON can, depending on the structure\nof an algorithm, achieve speedups of 1.5x to 16x.', 'editor': 'Gerhard Fettweis and\nWolfgang Nebel', 'title': '{A}dvanced {S{I}MD:} {E}xtending the reach of contemporary {S{I}MD} architectures', 'acceptance': '22', 'booktitle': 'Design, Automation {\\&} Test in Europe Conference {\\&} Exhibition\n({DATE} 2014)', 'location': 'Dresden, Germany', 'pages': '1-4', 'publisher': 'European Design and Automation Association', 'day': '24-28', 'month': 'March', 'year': '2014', 'doi': '10.7873/DATE.2014.037', 'ar_shortname': 'DATE 14', 'ENTRYTYPE': 'inproceedings', 'ID': 'DBLP:conf/date/BoettcherAEGR14', 'file': 'date2014_adv_simd.pdf', 'ar_file': 'DATE_14', 'ar_title': 'Advanced SIMD: Extending the reach of contemporary SIMD architectures'}, {'author': "Alastair D. Reid and\nKriszti{\\'a}n Flautner and\nEdmund Grimley{-}Evans and\nYuan Lin", 'title': '{S}oC-{C}: efficient programming abstractions for heterogeneous multicore\nsystems on chip', 'affiliation': 'ARM Ltd and University of Michigan', 'abstract': 'The architectures of system-on-chip (SoC) platforms found in high-end\nconsumer devices are getting more and more complex as designers strive\nto deliver increasingly compute-intensive applications on\nnear-constant energy budgets.  Workloads running on these platforms\nrequire the exploitation of heterogeneous parallelism and increasingly\nirregular memory hierarchies.  The conventional approach to\nprogramming such hardware is very low-level but this yields software\nwhich is intimately and inseparably tied to the details of the\nplatform it was originally designed for, limiting the software\\textquotesingle s\nportability, and, ultimately, the architectural choices available to\ndesigners of future platform generations.  The key insight of this\npaper is that many of the problems experienced in mapping applications\nonto SoC platforms come not from deciding how to map a program onto\nthe hardware but from the need to restructure the program and the\nnumber of interdependencies introduced in the process of implementing\nthose decisions.  We tackle this complexity with a set of language\nextensions which allows the programmer to introduce pipeline\nparallelism into sequential programs, manage distributed memories, and\nexpress the desired mapping of tasks to resources.  The compiler takes\ncare of the complex, error-prone details required to implement that\nmapping.  We demonstrate the effectiveness of SoC-C and its compiler\nwith a \\textasciigrave \\textasciigrave software defined radio\\textquotesingle \\textquotesingle  example (the PHY layer of a Digital\nVideo Broadcast receiver) achieving a 3.4x speedup on 4 cores.', 'editor': 'Erik R. Altman', 'acceptance': '33', 'booktitle': 'Proceedings of the 2008 International Conference on Compilers, Architecture, and Synthesis for Embedded Systems ({CASES} 2008)', 'location': 'Atlanta, GA, USA', 'pages': '95--104', 'publisher': 'ACM', 'day': '19-24', 'month': 'October', 'year': '2008', 'doi': '10.1145/1450095.1450112', 'ar_shortname': 'CASES 08', 'ENTRYTYPE': 'inproceedings', 'ID': 'DBLP:conf/cases/ReidFGL08', 'file': 'cases2008-SoC-C.pdf', 'ar_file': 'CASES_08', 'ar_title': 'SoC-C: efficient programming abstractions for heterogeneous multicore systems on chip'}, {'author': "Mark Woh and\nYuan Lin and\nSangwon Seo and\nScott A. Mahlke and\nTrevor N. Mudge and\nChaitali Chakrabarti and\nRichard Bruce and\nDanny Kershaw and\nAlastair Reid and\nMladen Wilder and\nKriszti{\\'a}n Flautner", 'title': '{F}rom {S{O}DA} to scotch: {T}he evolution of a wireless baseband processor', 'affiliation': 'ARM Ltd and University of Michigan and Arizona State University', 'abstract': 'With the multitude of existing and upcoming wireless standards, it is becoming\nincreasingly difficult for hardware-only baseband processing solutions to adapt\nto the rapidly changing wireless communication landscape. Software Defined\nRadio (SDR) promises to deliver a cost effective and flexible solution by\nimplementing a wide variety of wireless protocols in software. In previous\nwork, a fully programmable multicore architecture, SODA, was proposed that was\nable to meet the real-time requirements of 3G wireless protocols. SODA consists\nof one ARM control processor and four wide single instruction multiple data\n(SIMD) processing elements. Each processing element consists of a scalar and\na wide 512-bit 32-lane SIMD datapath. A commercial prototype based on the SODA\narchitecture, Ardbeg (named after a brand of Scotch Whisky), has been\ndeveloped. In this paper, we present the architectural evolution of going from\na research design to a commercial prototype, including the goals, trade-offs, and final design choices.\n\nArdbeg\\textquotesingle s redesign process can be grouped into the following three major areas:\noptimizing the wide SIMD datapath, providing long instruction word (LIW)\nsupport for SIMD operations, and adding application-specific hardware\naccelerators. Because SODA was originally designed with 180nm technology, the\nwide SIMD datapath is re-optimized in Ardbeg for 90nm technology. This includes\nre-evaluating the most efficient SIMD width, designing a wider SIMD shuffle\nnetwork, and implementing faster SIMD arithmetic units. Ardbeg also provides\nmodest LIW support by allowing two SIMD operations to issue in the same cycle.\nThis LIW execution supports SDR algorithms\\textquotesingle  most common parallel SIMD execution\npatterns with minimal hardware overhead. A viable commercial SDR solution must\nbe competitive with existing ASIC solutions. Therefore, algorithm-specific\nhardware is added for performance bottleneck algorithms while still maintaining\nenough flexibility to support multiple wireless protocols. The combination of\nthese architectural improvements allows Ardbeg to achieve 1.5-7x speedup over\nSODA across multiple wireless algorithms while consuming less power.', 'acceptance': '19', 'booktitle': '41st Annual {IEEE/ACM} International Symposium on Microarchitecture\n{(MICRO-41} 2008)', 'month': 'November', 'day': '8-12', 'location': 'Lake Como, Italy', 'pages': '152--163', 'publisher': '{IEEE} Computer Society', 'year': '2008', 'doi': '10.1109/MICRO.2008.4771787', 'ar_shortname': 'MICRO 08', 'ENTRYTYPE': 'inproceedings', 'ID': 'DBLP:conf/micro/WohLSMMCBKRWF08', 'file': 'mwoh-micro08.pdf', 'ar_file': 'MICRO_08', 'ar_title': 'From SODA to scotch: The evolution of a wireless baseband processor'}, {'author': 'Emre {\\"O}zer and\nAlastair Reid and\nStuart Biles', 'title': '{L}ow-cost {T}echniques for {R}educing {B}ranch {C}ontext {P}ollution in a {S}oft\n{R}ealtime {E}mbedded {M}ultithreaded {P}rocessor', 'affiliation': 'ARM Ltd', 'abstract': 'In this paper, we propose two low-cost and novel branch history\nbuffer handling schemes aiming at skewing the branch prediction\naccuracy in favor of a real-time thread for a soft real-time\nembedded multithreaded processor. The processor core accommodates\ntwo running threads, one with the highest priority and the other\nthread is a background thread, and both threads share the branch\npredictor. The first scheme uses a 3-bit branch history buffer in\nwhich the highest priority thread uses the most significant\n2 bits to change the prediction state while the background thread\nuses only the least significant 2 bits. The second scheme uses\nthe shared 2-bit branch history buffer that implements integer\nupdates for the highest priority thread but fractional updates\nfor the background thread in order to achieve relatively higher\nprediction accuracy in the highest priority thread. The low cost\nnature of these two schemes, particularly in the second scheme, makes them attractive with moderate improvement in the\nperformance of the highest priority thread.', 'booktitle': '19th Symposium on Computer Architecture and High Performance Computing\n{(SBAC-PAD} 2007)', 'day': '24-27', 'month': 'October', 'location': 'Gramado, RS, Brazil', 'pages': '37--44', 'publisher': '{IEEE} Computer Society', 'year': '2007', 'doi': '10.1109/SBAC-PAD.2007.15', 'ar_shortname': 'SBAC-PAD 07', 'ENTRYTYPE': 'inproceedings', 'ID': 'DBLP:conf/sbac-pad/OzerRB07', 'file': 'SBACPAD07.pdf', 'ar_file': 'SBAC_PAD_07', 'ar_title': 'Low-cost Techniques for Reducing Branch Context Pollution in a Soft Realtime Embedded Multithreaded Processor'}, {'author': "Yuan Lin and\nScott A. Mahlke and\nTrevor N. Mudge and\nChaitali Chakrabarti and\nAlastair Reid and\nKriszti{\\'a}n Flautner", 'title': '{D}esign and {I}mplementation of {T}urbo {D}ecoders for {S}oftware {D}efined {R}adio', 'affiliation': 'ARM Ltd and University of Michigan and Arizona State University', 'abstract': 'Software Defined Radio(SDR) is an emerging paradigm for wireless\nterminals, in which the physical layer of communication\nprotocols is implemented in software rather than by ASICs. Many\nof the current and next generation wireless protocols include\nTurbo coding because of its superior performance. However, Turbo\ndecoding is computationally intensive, and its low power\nimplementations have typ- ically been in ASICs. This paper\npresents a case study of algorithm-architecture co-design of\nTurbo decoder for SDR. We present a programmable DSP architecture\nfor SDR that includes a set of architectural features to\naccelerate Turbo decoder computations. We then present a parallel\nwindow scheduling for MAX-Log-MAP component decoder that\nmatches well with the DSP architecture. Finally, we present\na software implementation of Turbo decoder for W-CDMA on the DSP\narchitecture and show that it achieves 2Mbps decoding throughput.', 'booktitle': 'Proceedings of the {IEEE} Workshop on Signal Processing Systems\n(SiPS 2006)', 'month': 'October', 'day': '2-4', 'location': 'Banff, Alberta, Canada', 'pages': '22--27', 'publisher': 'IEEE', 'year': '2006', 'doi': '10.1109/SIPS.2006.352549', 'ar_shortname': 'SiPS 06', 'ENTRYTYPE': 'inproceedings', 'ID': 'DBLP:conf/sips/LinMMCRF06', 'file': 'lin-sips06.pdf', 'ar_file': 'SiPS_06', 'ar_title': 'Design and Implementation of Turbo Decoders for Software Defined Radio'}, {'author': "Yuan Lin and Robert Mullenix and Mark Woh and Scott Mahlke\nand Trevor Mudge Alastair Reid and Kriszti{\\'a}n Flautner", 'title': 'S{P}EX: {A} programming language for software defined radio', 'booktitle': 'Software Defined Radio Technical Conference and Product Exposition', 'day': '13-17', 'month': 'November', 'location': 'Orlando, FL, USA', 'ar_shortname': 'SDR 06', 'affiliation': 'ARM Ltd and University of Michigan', 'abstract': 'High-throughput, low-power Software Defined Radio(SDR)\nsolutions require multi-core SIMD DSP processors to meet\nreal-time performance requirements. Given the difficulty in\nprogramming traditional DSPs, these new multi-core signal\nprocessors provide even greater challenges for programmers and\ncompilers. In this paper, we describe SPEX, a programming\nlanguage which is aimed at narrowing the semantic gap between\nthe description of complex SDR systems and their\nimplementations. SPEX supports three different types of\nprogramming semantics, allowing SDR solutions to be developed\nwith a divide-and-conquer approach. For DSP algorithm\nkernels, SPEX is able to support DSP arithmetics and\nfirst-class vector and matrix variables with sequential\nlanguage semantics. From wireless protocol channels, it is able\nto support sequences of data-processing computations with\ndataflow language semantics. And for protocol systems, it is\nable to support real-time deadlines and concurrent executions\nwith synchronous language semantics. The design choices are\nmotivated by our experience implementing W-CDMA protocol on\na reprogrammable substrate. In the paper, we also briefly\nexplain SPEX\\textquotesingle s compilation strategies.', 'year': '2006', 'ENTRYTYPE': 'inproceedings', 'ID': 'conf:SDR:LinMW2006', 'file': 'lin-sdr06.pdf', 'ar_file': 'SDR_06', 'ar_title': 'SPEX: A programming language for software defined radio'}, {'author': 'John Regehr and\nAlastair Reid and\nKirk Webb', 'title': '{E}liminating stack overflow by abstract interpretation', 'affiliation': 'University of Utah', 'abstract': 'An important correctness criterion for software running on\nembedded microcontrollers is stack safety: a guarantee that the\ncall stack does not overflow. Our first contribution is a method\nfor statically guaranteeing stack safety of interrupt-driven\nembedded software using an approach based on context-sensitive\ndataflow analysis of object code. We have implemented a prototype\nstack analysis tool that targets software for Atmel AVR\nmicrocontrollers and tested it on embedded applications compiled\nfrom up to 30,000 lines of C. We experimentally validate the\naccuracy of the tool, which runs in under 10 sec on the largest\nprograms that we tested. The second contribution of this paper is\nthe development of two novel ways to reduce stack memory\nrequirements of embedded software.', 'journal': '{ACM} Transactions Embedded Computing Systems', 'volume': '4', 'number': '4', 'pages': '751--778', 'year': '2005', 'doi': '10.1145/1113830.1113833', 'ar_shortname': 'TECS 05', 'ENTRYTYPE': 'article', 'ID': 'DBLP:journals/tecs/RegehrRW05', 'file': 'p751-regehr.pdf', 'ar_file': 'TECS_05', 'ar_title': 'Eliminating stack overflow by abstract interpretation'}, {'author': 'John Regehr and\nAlastair Reid', 'editor': 'Shubu Mukherjee and\nKathryn S. McKinley', 'title': '{H{O}IS{T}:} a system for automatically deriving static analyzers for\nembedded systems', 'affiliation': 'University of Utah', 'abstract': 'Embedded software must meet conflicting requirements such as be-\ning highly reliable, running on resource-constrained platforms, and being developed rapidly. Static program analysis can help\nmeet all of these goals. People developing analyzers for embedded\nobject code face a difficult problem: writing an abstract version\nof each instruction in the target architecture(s). This is\ncurrently done by hand, resulting in abstract operations that are\nboth buggy and imprecise. We have developed Hoist: a novel\nsystem that solves these problems by automatically constructing\nabstract operations using a microprocessor (or simulator) as its\nown specification. With almost no input from a human, Hoist\ngenerates a collection of C functions that are ready to be\nlinked into an abstract interpreter. We demonstrate that Hoist\ngenerates abstract operations that are correct, having been\nextensively tested, sufficiently fast, and substantially more\nprecise than manually written abstract operations. Hoist is\ncurrently limited to eight-bit machines due to costs exponential\nin the word size of the target architecture. It is essential to\nbe able to analyze software running on these small processors:\nthey are important and ubiquitous, with many embedded and\nsafety-critical systems being based on them.', 'acceptance': '14', 'booktitle': 'Proceedings of the 11th International Conference on Architectural\nSupport for Programming Languages and Operating Systems ({ASPLOS}\n2004)', 'location': 'Boston, MA, USA', 'month': 'October', 'day': '7-13', 'pages': '133--143', 'publisher': 'ACM', 'year': '2004', 'doi': '10.1145/1024393.1024410', 'ar_shortname': 'ASPLOS 04', 'ENTRYTYPE': 'inproceedings', 'ID': 'DBLP:conf/asplos/RegehrR04', 'file': 'p021-regehr.pdf', 'ar_file': 'ASPLOS_04', 'ar_title': 'HOIST: a system for automatically deriving static analyzers for embedded systems'}, {'title': '{L}ock inference for systems software', 'author': 'John Regehr and Alastair Reid', 'affiliation': 'University of Utah', 'abstract': 'We have developed task scheduler logic (TSL) to automate\nreasoning about scheduling and concurrency in systems software.\nTSL can detect race conditions and other errors as well as\nsupporting lock inference: the derivation of an appropriate\nlock implementation for each critical section in a system. Lock\ninference solves a number of problems in creating flexible, reliable, and efficient systems software. TSL is based on\na notion of asymmetrical preemption relations and it exploits\nthe hierarchical inheritance of scheduling properties that is\ncommon in systems software.', 'booktitle': 'Proceedings of the Second AOSD Workshop on Aspects, Components, and Patterns for Infrastructure Software (ACP4IS)', 'ar_shortname': 'ACP4IS 03', 'location': 'Boston, MA, USA', 'month': 'March', 'year': '2003', 'day': '17', 'ENTRYTYPE': 'inproceedings', 'ID': 'tsl-acp4is2003', 'file': 'tsl-acp4is.pdf', 'ar_file': 'ACP4IS_03', 'ar_title': 'Lock inference for systems software'}, {'author': 'John Regehr and\nAlastair Reid and\nKirk Webb', 'editor': 'Rajeev Alur and\nInsup Lee', 'title': '{E}liminating {S}tack {O}verflow by {A}bstract {I}nterpretation', 'affiliation': 'University of Utah', 'abstract': 'An important correctness criterion for software running on\nembedded microcontrollers is stack safety: a guarantee that the\ncall stack does not overflow. We address two aspects of the\nproblem of creating stack-safe embedded software that also makes\nefficient use of memory: statically bounding worst-case stack\ndepth, and automatically reducing stack memory requirements. Our\nfirst contribution is a method for statically guaranteeing stack\nsafety by performing whole-program analysis, using an approach\nbased on context-sensitive abstract interpretation of machine\ncode. Abstract interpretation permits our analysis to accurately\nmodel when interrupts are enabled and disabled, which is\nessential for accurately bounding the stack depth of typical\nembedded systems. We have implemented a stack analysis tool that\ntargets Atmel AVR microcontrollers, and tested it on embedded\napplications compiled from up to 30,000 lines of C. We\nexperimentally validate the accuracy of the tool, which runs in\na few seconds on the largest programs that we tested. The second\ncontribution of this paper is a novel framework for automatically\nreducing stack memory requirements. We show that goal-directed\nglobal function inlining can be used to reduce the stack memory\nrequirements of component-based embedded software, on average, to\n40\\% of the requirement of a system compiled without inlining, and\nto 68\\% of the requirement of a system compiled with aggressive\nwhole-program inlining that is not directed towards reducing\nstack usage.', 'booktitle': 'Embedded Software, Third International Conference ({EMSOFT} 2003)', 'location': 'Philadelphia, PA, USA', 'month': 'October', 'day': '13-15', 'series': 'Lecture Notes in Computer Science', 'volume': '2855', 'pages': '306--322', 'publisher': 'Springer', 'year': '2003', 'doi': '10.1007/978-3-540-45212-6\\_20', 'ar_shortname': 'EMSOFT 03', 'ENTRYTYPE': 'inproceedings', 'ID': 'DBLP:conf/emsoft/RegehrRW03', 'file': 'emsoft03-preprint.pdf', 'ar_file': 'EMSOFT_03', 'ar_title': 'Eliminating Stack Overflow by Abstract Interpretation'}, {'author': 'John Regehr and\nAlastair Reid and\nKirk Webb and\nMichael A. Parker and\nJay Lepreau', 'title': '{E}volving real-time systems using hierarchical scheduling and concurrency\nanalysis', 'affiliation': 'University of Utah', 'abstract': 'We have developed a new way to look at real-time and embedded\nsoftware: as a collection of execution environments created by\na hierarchy of schedulers. Common schedulers include those that run\ninterrupts, bottom-half handlers, threads, and events. We have\ncreated algorithms for deriving response times, scheduling overheads, and blocking terms for tasks in systems containing multiple execution\nenvironments. We have also created task scheduler logic, a formalism\nthat permits checking systems for race conditions and other errors.\nConcurrency analysis of low-level software is challenging because\nthere are typically several kinds of locks, such as thread mutexes\nand disabling interrupts, and groups of cooperating tasks may need to\nacquire some, all, or none of the available types of locks to create\ncorrect software. Our high level goal is to create systems that are\nevolvable: they are easier to modify in response to changing\nrequirements than are systems created using traditional techniques.\nWe have applied our approach to two case studies in evolving software\nfor networked sensor nodes.', 'booktitle': 'Proceedings of the 24th {IEEE} Real-Time Systems Symposium ({RTSS} 2003)', 'day': '3-5', 'month': 'December', 'location': 'Cancun, Mexico', 'pages': '25--36', 'publisher': '{IEEE} Computer Society', 'year': '2003', 'doi': '10.1109/REAL.2003.1253251', 'ar_shortname': 'RTSS 03', 'ENTRYTYPE': 'inproceedings', 'ID': 'DBLP:conf/rtss/RegehrRWPL03', 'file': 'rtss03-preprint.pdf', 'ar_file': 'RTSS_03', 'ar_title': 'Evolving real-time systems using hierarchical scheduling and concurrency analysis'}, {'title': '{T}he {H}askell 98 {F}oreign {F}unction {I}nterface 1.0: {A}n {A}ddendum to the {H}askell 98 {R}eport', 'ar_shortname': 'Haskell FFI', 'author': 'Manuel Chakravarty\nand Sigbjorn Finne\nand Fergus Henderson\nand Marcin Kowalczyk\nand Daan Leijen\nand Simon Marlow\nand Erik Meijer\nand Sven Panne\nand Simon Peyton Jones\nand Alastair Reid\nand Malcolm Wallace\nand Michael Weber', 'year': '2003', 'link': 'https://www.cse.unsw.edu.au/\\textasciitilde chak/haskell/ffi', 'ENTRYTYPE': 'article', 'ID': 'report:haskellffi:chakravarty2003', 'file': 'ffi.pdf', 'ar_file': 'Haskell_FFI', 'ar_title': 'The Haskell 98 Foreign Function Interface 1.0: An Addendum to the Haskell 98 Report'}, {'author': 'Eric Eide and\nAlastair Reid and\nJohn Regehr and\nJay Lepreau', 'editor': 'Will Tracz and\nMichal Young and\nJeff Magee', 'title': '{S}tatic and dynamic structure in design patterns', 'acceptance': '15', 'affiliation': 'University of Utah', 'abstract': 'Design patterns are a valuable mechanism for emphasizing\nstructure, capturing design expertise, and facilitating restructuring of\nsoftware systems. Patterns are typically applied in the context of an\nobject-oriented language and are implemented so that the pattern\nparticipants correspond to object instances that are created and\nconnected at run-time. This paper describes a complementary\nrealization of design patterns, in which many pattern participants\ncorrespond to statically instantiated and connected components.Our\napproach separates the static parts of the software design from the\ndynamic parts of the system behavior. This separation makes the\nsoftware design more amenable to analysis, thus enabling more\neffective and domain-specific detection of system design errors, prediction of run-time behavior, and more effective optimization. This\ntechnique is applicable to imperative, functional, and\nobject-oriented languages: we have extended C, Scheme, and Java with\nour component model. In this paper, we illustrate our approach in the\ncontext of the OSKit, a collection of operating system components\nwritten in C.', 'booktitle': 'Proceedings of the 24th International Conference on Software Engineering\n({ICSE} 2002)', 'day': '19-25', 'month': 'May', 'location': 'Orlando, Florida, {USA}', 'pages': '208--218', 'publisher': 'ACM', 'year': '2002', 'doi': '10.1145/581339.581367', 'ar_shortname': 'ICSE 02', 'ENTRYTYPE': 'inproceedings', 'ID': 'DBLP:conf/icse/EideRRL02', 'file': 'knit-icse02.pdf', 'ar_file': 'ICSE_02', 'ar_title': 'Static and dynamic structure in design patterns'}, {'author': 'Eric Eide and Alastair Reid and Matthew Flatt and Jay Lepreau', 'title': '{A}spect {W}eaving as {C}omponent {K}nitting: {S}eparating {C}oncerns with {K}nit', 'ar_shortname': 'ASPSE 01', 'affiliation': 'University of Utah', 'abstract': 'Knit is a new component specification and linking language. It\nwas initially designed for low-level systems software, which\nrequires especially flexible components with especially\nwell-defined interfaces. For example, threads and virtual memory\nare typically implemented by components within the system, instead of being supplied by some execution environment.\nConsequently, components used to construct the system must expose\ninteractions with threads and memory. The component composition\ntool must then check the resulting system for correctness, and\nweave the components together to achieve reasonable performance.\n\nComponent composition with Knit thus acts like aspect weaving: component\ninterfaces determine the \\textquotedblleft join points\\textquotedblright  for weaving, while components (some of\nwhich may be automatically generated) implement aspects. Knit is not limited to\nthe construction of low-level software, and to the degree that a set of\ncomponents exposes fine-grained relationships, Knit provides the benefits\nof aspect-oriented programming within its component model.', 'booktitle': 'Workshop on Advanced Separation of Concerns in Software Engineering', 'location': 'Toronto, Ontario, Canada', 'month': 'May', 'year': '2001', 'ENTRYTYPE': 'inproceedings', 'ID': 'EEide01Aspect', 'file': 'knit-icse01-wasc.pdf', 'ar_file': 'ASPSE_01', 'ar_title': 'Aspect Weaving as Component Knitting: Separating Concerns with Knit'}, {'author': 'John Peterson and\nPaul Hudak and\nAlastair Reid and\nGregory D. Hager', 'editor': 'I. V. Ramakrishnan', 'title': 'F{V}ision: {A} {D}eclarative {L}anguage for {V}isual {T}racking', 'affiliation': 'Yale University', 'abstract': 'Functional programming languages are not generally associated\nwith computationally intensive tasks such as computer vision. We show\nthat a declarative programming language like Haskell is effective for\ndescribing complex visual tracking systems. We have taken an existing\nC++ library for computer vision, called XVision, and used it to build\nFVision (pronounced \\textasciigrave \\textasciigrave fission\\textquotesingle \\textquotesingle ), a library of Haskell types and\nfunctions that provides a high-level interface to the lower-level\nXVision code. Using functional abstractions, users of FVision can\nbuild and test new visual tracking systems rapidly and reliably. The\nuse of Haskell does not degrade system performance: computations are\ndominated by low-level calculations expressed in C++ while the\nHaskell \\textasciigrave \\textasciigrave glue code\\textquotesingle \\textquotesingle  has a negligible impact on performance.\n\nFVision is built using functional reactive programming (FRP) to\nexpress interaction in a purely functional manner. The resulting\nsystem demonstrates the viability of mixed-language programming:\nvisual tracking programs continue to spend most of their time\nexecuting low-level image-processing code, while Haskell\\textquotesingle s advanced\nfeatures allow us to develop and test systems quickly and with\nconfidence. In this paper, we demonstrate the use of Haskell and FRP\nto express many basic abstractions of visual tracking.', 'booktitle': 'Practical Aspects of Declarative Languages, Third International Symposium\n({PADL} 2001)', 'location': 'Las Vegas, Nevada, USA', 'month': 'March', 'day': '11-12', 'series': 'Lecture Notes in Computer Science', 'volume': '1990', 'pages': '304--321', 'publisher': 'Springer', 'year': '2001', 'doi': '10.1007/3-540-45241-9\\_21', 'ar_shortname': 'PADL 01', 'ENTRYTYPE': 'inproceedings', 'ID': 'DBLP:conf/padl/PetersonHRH01', 'file': 'fvision-padl01-2.pdf', 'ar_file': 'PADL_01', 'ar_title': 'FVision: A Declarative Language for Visual Tracking'}, {'author': 'Alastair Reid', 'title': '{T}he {H}ugs {G}raphics {L}ibrary ({V}ersion 2.0)', 'affiliation': 'Yale University', 'location': 'New Haven, CT, USA', 'ar_shortname': 'GLib 01', 'year': '2001', 'ENTRYTYPE': 'misc', 'ID': 'hugsgraphics2001', 'file': 'hugsgraphics.pdf', 'ar_file': 'GLib_01', 'ar_title': 'The Hugs Graphics Library (Version 2.0)'}, {'author': 'Alastair Reid and\nMatthew Flatt and\nLeigh Stoller and\nJay Lepreau and\nEric Eide', 'editor': 'Michael B. Jones and\nM. Frans Kaashoek', 'title': '{K}nit: {C}omponent {C}omposition for {S}ystems {S}oftware', 'affiliation': 'University of Utah', 'abstract': 'Knit is a new component definition and linking language for\nsystems code. Knit helps make C code more understandable and reusable by\nthird parties, helps eliminate much of the performance overhead of\ncomponentization, detects subtle errors in component composition that\ncannot be caught with normal component type systems, and provides\na foundation for developing future analyses over C-based components, such as cross-component optimization. The language is especially designed\nfor use with component kits, where standard linking tools provide\ninadequate support for component configuration. In particular, we\ndeveloped Knit for use with the OSKit, a large collection of\ncomponents for building low-level systems. However, Knit is\nnot OSKit-specific, and we have implemented parts of the\nClick modular router in terms of Knit components to\nillustrate the expressiveness and flexibility of our\nlanguage. This paper provides an overview of the Knit\nlanguage and its applications.', 'booktitle': '4th Symposium on Operating System Design and Implementation ({OSDI} 2000)', 'location': 'San Diego, California, USA', 'month': 'October', 'day': '23-25', 'pages': '347--360', 'publisher': '{USENIX} Association', 'year': '2000', 'ar_shortname': 'OSDI 00', 'link': 'http://dl.acm.org/citation.cfm?id=1251253', 'ENTRYTYPE': 'inproceedings', 'ID': 'DBLP:conf/osdi/ReidFSLE00', 'file': 'knit-osdi00.pdf', 'ar_file': 'OSDI_00', 'ar_title': 'Knit: Component Composition for Systems Software'}, {'author': 'Alastair Reid and\nJohn Peterson and\nGregory D. Hager and\nPaul Hudak', 'editor': 'Barry W. Boehm and\nDavid Garlan and\nJeff Kramer', 'title': '{P}rototyping {R}eal-{T}ime {V}ision {S}ystems: {A}n {E}xperiment in {D{S}L} {D}esign', 'acceptance': '19', 'affiliation': 'Yale University', 'abstract': 'We describe the transformation of XVision, a large library of\nC++ code for real-time vision processing, into FVision (pronounced\n\\textasciigrave \\textasciigrave fission\\textquotesingle \\textquotesingle ), a fully-featured domain-specific language embedded\nin Haskell. The resulting prototype system substantiates the claims\nof increased modularity, effective code reuse, and rapid prototyping\nthat characterize the DSL approach to system design. It also\nillustrates the need for judicious interface design: relegating\ncomputationally expensive tasks to XVision (pre-existing C++\ncomponents), and leaving modular compositional tasks to\nFVision (Haskell). At the same time, our experience demonstrates how\nHaskell\\textquotesingle s advanced language features (specifically parametric\npolymorphism, lazy evaluation, higher order functions and\nautomatic storage reclamation) permit a rapid DSL design that\nis itself highly modular and easily modified. Overall, the resulting\nhybrid system exceeded our expectations: visual tracking programs\ncontinue to spend most of their time executing low level\nimage-processing code, while Haskell\\textquotesingle s advanced features allow us to\nquickly develop and test small prototype systems within a matter of\na few days and to develop realistic applications within a few weeks.', 'booktitle': 'Proceedings of the 1999 International Conference on Software Engineering\n({ICSE} \\textquotesingle 99)', 'location': 'Los Angeles, CA, USA', 'month': 'May', 'day': '16-22', 'pages': '484--493', 'publisher': 'ACM', 'year': '1999', 'doi': '10.1109/icse.1999.841038', 'ar_shortname': 'ICSE 99', 'ENTRYTYPE': 'inproceedings', 'ID': 'DBLP:conf/icse/ReidPHH99', 'file': 'fvision-icse99-2.pdf', 'ar_file': 'ICSE_99', 'ar_title': 'Prototyping Real-Time Vision Systems: An Experiment in DSL Design'}, {'author': 'Simon L. Peyton Jones and\nAlastair Reid and\nFergus Henderson and\nC. A. R. Hoare and\nSimon Marlow', 'editor': 'Barbara G. Ryder and\nBenjamin G. Zorn', 'title': '{A} Semantics for {I}mprecise {E}xceptions', 'acceptance': '20', 'affiliation': 'Yale University and Microsoft Research and Cambridge University\nand University of Melbourne', 'abstract': 'Some modern superscalar microprocessors provide only imprecise\nexceptions. That is, they do not guarantee to report the same exception\nthat would be encountered by a straightforward sequential execution\nof the program. In exchange, they offer increased performance or\ndecreased area (which amount to much the same thing).\n\nThis performance/precision tradeoff has not so far been much explored at\nthe programming language level. In this paper we propose a design for\nimprecise exceptions in the lazy functional programming language Haskell.\nWe discuss various simpler designs, and conclude that imprecision is\nessential if the language is still to enjoy its current rich algebra of\ntransformations. We sketch a precise semantics for the language extended\nwith exceptions.\n\nFrom the functional programming point of view, the paper shows how to\nextend Haskell with exceptions without crippling the language or its\ncompilers. From the point of view of the wider programming language\ncommunity, we pose the question of whether precision and performance\ncan be traded off in other languages too.', 'booktitle': 'Proceedings of the 1999 {ACM} {SIGPLAN} Conference on Programming\nLanguage Design and Implementation (PLDI \\textquotesingle 99)', 'location': 'Atlanta, Georgia, USA', 'month': 'May', 'day': '1-4', 'pages': '25--36', 'publisher': 'ACM', 'year': '1999', 'doi': '10.1145/301618.301637', 'ar_shortname': 'PLDI 99', 'ENTRYTYPE': 'inproceedings', 'ID': 'DBLP:conf/pldi/JonesRHHM99', 'file': 'except.pdf', 'ar_file': 'PLDI_99', 'ar_title': 'A Semantics for Imprecise Exceptions'}, {'title': '{H}askell 98: {A} non-strict, purely functional language', 'ar_shortname': 'Haskell Report', 'author': 'Simon Peyton Jones\nand Lennart Augustsson\nand Dave Barton\nand Brian Boutel\nand Warren Burton\nand Joseph Fasel\nand Kevin Hammond\nand Ralf Hinze\nand Paul Hudak\nand John Hughes\nand Thomas Johnsson\nand Mark Jones\nand John Launchbury\nand Erik Meijer\nand John Peterson\nand Alastair Reid\nand Colin Runciman\nand Philip Wadler', 'year': '1999', 'link': 'https://www.haskell.org/definition/', 'ENTRYTYPE': 'misc', 'ID': 'report:haskell98report:jones1999', 'file': 'haskell98-report.pdf', 'ar_file': 'Haskell_Report', 'ar_title': 'Haskell 98: A non-strict, purely functional language'}, {'title': '{S}tandard {L}ibraries for the {H}askell 98 {P}rogramming {L}anguage', 'ar_shortname': 'Haskell Lib', 'author': 'Simon Peyton Jones\nand Lennart Augustsson\nand Dave Barton\nand Brian Boutel\nand Warren Burton\nand Joseph Fasel\nand Kevin Hammond\nand Ralf Hinze\nand Paul Hudak\nand John Hughes\nand Thomas Johnsson\nand Mark Jones\nand John Launchbury\nand Erik Meijer\nand John Peterson\nand Alastair Reid\nand Colin Runciman\nand Philip Wadler', 'year': '1999', 'link': 'https://www.haskell.org/definition/', 'ENTRYTYPE': 'misc', 'ID': 'report:haskell98libraries:jones1999', 'file': 'haskell98-library.pdf', 'ar_file': 'Haskell_Lib', 'ar_title': 'Standard Libraries for the Haskell 98 Programming Language'}, {'author': 'Alastair Reid', 'editor': 'Kevin Hammond and\nAntony J. T. Davie and\nChris Clack', 'title': '{P}utting the {S}pine {B}ack in the {S}pineless {T}agless {G}-Machine: {A}n {I}mplementation\nof {R}esumable {B}lack-{H}oles', 'affiliation': 'Yale University', 'abstract': 'Interrupt handling is a tricky business in lazy functional\nlanguages: we have to make sure that thunks that are being evaluated can\nbe halted and later restarted if and when they are required. This is\na particular problem for implementations which use black-holing.\nBlack-Holing deliberately makes it impossible to revert such thunks\nto their original state to avoid a serious space leak. Interactive\nHaskell implementations such as Hugs and hbi catch interrupts and\navoid the problem by omitting or disabling black-holing. Batch mode\nHaskell implementations such as HBC and the Glasgow Haskell Compiler\n(GHC) avoid this problem by disabling black-holing or by providing no\nway to catch interrupts. This paper describes a modification to GHC\\textquotesingle s\nabstract machine (the Spineless Tagless G-Machine) which\nsimultaneously supports both interrupts and black-holing.', 'booktitle': 'Implementation of Functional Languages, 10th International Workshop\n({IFL}\\textquotesingle 98) Selected Papers', 'location': 'London, UK', 'month': 'September', 'day': '9-11', 'series': 'Lecture Notes in Computer Science', 'volume': '1595', 'pages': '186--199', 'publisher': 'Springer', 'year': '1998', 'doi': '10.1007/3-540-48515-5\\_12', 'ar_shortname': 'IFL 98', 'ENTRYTYPE': 'inproceedings', 'ID': 'DBLP:conf/ifl/Reid98', 'file': 'spine-ifl98.pdf', 'ar_file': 'IFL_98', 'ar_title': 'Putting the Spine Back in the Spineless Tagless G-Machine: An Implementation of Resumable Black-Holes'}, {'author': 'Alastair Reid', 'title': '{H}andling {E}xceptions in {H}askell', 'ar_shortname': 'Exceptions', 'affiliation': 'Yale University', 'abstract': 'Using a language without exception handling is like driving\na car with no brakes and no seatbelt --- things work fine until\nsomething goes wrong. You also learn to drive rather carefully.\nThis paper describes an exception handling extension to the Haskell\nlazy functional language. The implementation turned out to be very\neasy but we had problems finding a viable semantics for our system.\nThe resulting semantics is a compromise between theoretical beauty\nand practical utility.', 'booktitle': 'Yale University Research Report YALE/DCS/RR-1178', 'location': 'New Haven, CT, USA', 'month': 'August', 'year': '1998', 'ENTRYTYPE': 'inproceedings', 'ID': 'Reid98exceptions', 'file': 'exceptions98.pdf', 'ar_file': 'Exceptions', 'ar_title': 'Handling Exceptions in Haskell'}, {'author': 'Alastair Reid and John Peterson', 'ar_shortname': 'StdLib 98', 'affiliation': 'Yale University', 'title': '{D}esigning the {S}tandard {H}askell {L}ibraries', 'year': '1998', 'ENTRYTYPE': 'misc', 'ID': 'Reid98haskelllibraries', 'file': 'libraries.pdf', 'ar_file': 'StdLib_98', 'ar_title': 'Designing the Standard Haskell Libraries'}, {'author': 'Simon Peyton Jones and Thomas Nordin and Alastair Reid', 'ar_shortname': 'Haskell 97', 'title': '{G}reen {C}ard: a foreign-language interface for {H}askell', 'affiliation': 'Yale University and Oregon Graduate Institute', 'booktitle': 'Proceedings of the Haskell Workshop', 'location': 'Amsterdam, Netherlands', 'month': 'June', 'year': '1997', 'ENTRYTYPE': 'inproceedings', 'ID': 'greencard1997', 'file': 'green-card.pdf', 'ar_file': 'Haskell_97', 'ar_title': 'Green Card: a foreign-language interface for Haskell'}, {'author': 'John Peterson and Alastair Reid', 'ar_shortname': 'Haskell 95a', 'title': '{A}dding {R}ecords to {H}askell', 'affiliation': 'Yale University', 'booktitle': 'Proceedings of the Haskell Workshop 1995, Yale University Research Report YALE/DCS/RR-1075', 'location': 'Portland, Oregon, USA', 'year': '1995', 'link': 'https://www.haskell.org/haskell-workshop/1995/HW1995-Proceedings.pdf', 'ENTRYTYPE': 'inproceedings', 'ID': 'Peterson95addingrecords', 'file': 'records.pdf', 'ar_file': 'Haskell_95a', 'ar_title': 'Adding Records to Haskell'}, {'author': 'Alastair Reid and John Peterson', 'ar_shortname': 'Haskell 95b', 'title': '{A} Proposal for the {S}tandard {H}askell {L}ibraries', 'affiliation': 'Yale University', 'booktitle': 'Proceedings of the Haskell Workshop 1995, Yale University Research Report YALE/DCS/RR-1075', 'location': 'Portland, Oregon, USA', 'year': '1995', 'page': '69-81', 'link': 'https://www.haskell.org/haskell-workshop/1995/HW1995-Proceedings.pdf', 'ENTRYTYPE': 'inproceedings', 'ID': 'Reid95haskelllibraries', 'file': 'HW1995-Proceedings.pdf', 'ar_file': 'Haskell_95b', 'ar_title': 'A Proposal for the Standard Haskell Libraries'}, {'author': 'Alastair Reid', 'ar_shortname': 'GFPW 94', 'title': '{M}alloc {P}ointers and {S}table {P}ointers: {I}mproving {H}askell\\textquotesingle s {F}oreign {L}anguage {I}nterface', 'affiliation': 'University of Glasgow', 'booktitle': 'Draft Proceedings of the Glasgow Functional Programming Workshop', 'location': 'Ayr, Scotland', 'day': '12\\textendash 14', 'month': 'September', 'year': '1994', 'ENTRYTYPE': 'inproceedings', 'ID': 'Reid94mallocpointers', 'file': 'malloc.pdf', 'ar_file': 'GFPW_94', 'ar_title': "Malloc Pointers and Stable Pointers: Improving Haskell's Foreign Language Interface"}, {'author': 'Alastair Reid and Satnam Singh', 'editor': 'John T. O\\textquotesingle Donnell and Kevin Hammond', 'title': '{I}mplementing {F}udgets with {S}tandard {W}idget {S}ets', 'affiliation': 'University of Glasgow', 'abstract': 'Carlsson and Hallgren describe the implementation of a set of\n"functional widgets" (Fudgets): components for programming graphical\nuser interfaces under the X window system using the non-strict\nfunctional programming language Haskell.\nWe describe an alternative implementation based on existing\nwidget sets (currently Openlook and Motif).\nOur purpose is twofold: to show that the Fudgets approach can be\napplied to existing widget sets; and to discuss problems experienced\nwith Fudgets during an industrial case study.', 'booktitle': 'Proceedings of the 1993 Glasgow Workshop on Functional Programming', 'location': 'Ayr, Scotland', 'day': '5-7', 'month': 'July', 'year': '1993', 'publisher': 'Springer London', 'address': 'London', 'pages': '222--235', 'isbn': '978-1-4471-3236-3', 'doi': '10.1007/978-1-4471-3236-3\\_18', 'ar_shortname': 'GFPW 93', 'ENTRYTYPE': 'inbook', 'ID': 'Reid1993', 'ar_file': 'GFPW_93', 'ar_title': 'Implementing Fudgets with Standard Widget Sets'}, {'author': 'Alastair Reid', 'title': '{A} Precise {S}emantics for {U}ltraloose {S}pecifications', 'affiliation': 'University of Glasgow', 'abstract': 'All formal specifiers face the danger of overspecification:\naccidentally writing an overly restrictive specification.\nThis problem is particularly acute for axiomatic specifications\nbecause it is so easy to write axioms that hold for some of the\nintended implementations but not for all of them (or, rather, it\nis hard not to write overly strong axioms).\n\nOne of the best developed ways of recovering some of these implementations\nwhich do not literally satisfy the specification is to apply a \\textasciigrave \\textasciigrave behavioural\nabstraction operator\\textquotesingle \\textquotesingle  to a specification: adding in those implementations\nwhich have the same \\textasciigrave \\textasciigrave behaviour\\textquotesingle \\textquotesingle  as an implementation which does satisfy\nthe specification.\n\nIn two recent papers, Broy and Wirsing propose an alternative (and apparently\nsimpler) approach which they call \\textasciigrave \\textasciigrave ultraloose specification.\\textquotesingle \\textquotesingle   This approach\nis based on a particular style of writing axioms which avoids certain forms\nof overspecification.\n\nAn important, unanswered question is \\textasciigrave \\textasciigrave How does the ultraloose approach relate\nto other solutions?\\textquotesingle \\textquotesingle  The major achievement of this thesis is a proof that the\nultraloose approach is semantically equivalent to the use of the \\textasciigrave \\textasciigrave behavioural\nabstraction operator.\\textquotesingle \\textquotesingle   This result is rather surprising in the light of a result\nby Schoett which seems to say that such a result is impossible.', 'school': 'Glasgow School of Computing Science', 'location': 'Glasgow, Scotland', 'ar_shortname': 'MSc 93', 'year': '1993', 'ENTRYTYPE': 'mastersthesis', 'ID': 'ReidThesis93', 'file': 'ReidThesis93.pdf', 'ar_file': 'MSc_93', 'ar_title': 'A Precise Semantics for Ultraloose Specifications'}, {'author': 'Alastair Reid', 'editor': 'Kei Davis and\nJohn Hughes', 'ar_shortname': 'GFPW 89', 'title': '{D}esigning {D}ata {S}tructures', 'affiliation': 'University of Glasgow', 'abstract': 'The design (as opposed to the choice and use) of data structures has\nbeen the subject of relatively little study in the context of formal methods.\nIn this paper, we introduce our ideas on how data structures are designed.', 'booktitle': 'Proceedings of the 1989 Glasgow Workshop on Functional Programming', 'day': '21-23', 'month': 'August', 'location': 'Fraserburgh, Scotland, {UK}', 'series': 'Workshops in Computing', 'pages': '170--181', 'publisher': 'Springer', 'year': '1989', 'ENTRYTYPE': 'inproceedings', 'ID': 'DBLP:conf/fp/Reid89', 'file': 'designing.pdf', 'ar_file': 'GFPW_89', 'ar_title': 'Designing Data Structures'}]

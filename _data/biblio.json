[{"title": "Who guards the guards? Formal Validation of the ARM v8-M Architecture Specification", "author": "Alastair Reid", "abstract": "Software and hardware are increasingly being formally verified against specifications, but how can we verify the specifications themselves? This talk explores what it means to formally verify a specification. We solve three challenges: (1) How to create a secondary, higher-level speci cation that can be effectively reviewed by processor designers who are not experts in formal verification; (2) How to avoid common-mode failures between the specifications; and (3) How to automatically verify the two specifications against each other.  One of the most important specifications for software verification is the processor specification since it de nes the behaviour of machine code and of hardware protection features used by operating systems. We demonstrate our approach on ARM\u2019s v8-M Processor Specification, which is intended to improve the security of Internet of Things devices. Thus, we focus on establishing the security guarantees the architecture is intended to provide. Despite the fact that the ARM v8-M specification had previously been extensively tested, we found twelve bugs (including two security bugs) that have all been fixed by ARM.", "booktitle": "Proceedings of the ACM on Programming Languages", "series": "OOPSLA 2017", "year": "2017", "volume": "1", "number": "OOPSLA", "month": "October", "day": "22\u201327", "doi": "10.1145/3133912", "ar_shortname": "OOPSLA 17", "location": "Vancouver, Canada", "numpages": "24", "publisher": "ACM", "address": "New York, NY, USA", "ENTRYTYPE": "article", "ID": "conf/oopsla/Reid17", "file": "oopsla2017-whoguardstheguards.pdf", "slides": "oopsla2017-whoguardstheguards-slides.pdf"}, {"title": "The ARM Scalable Vector Extension", "author": "Nigel Stephens, Stuart Biles, Matthias Boettcher, Jacob Eapen, Mbou Eyole, Giacomo Gabrielli, Matt Horsnell, Grigorios Magklis, Alejandro Martinez, Nathanael Premillieu, Alastair Reid, Alejandro Rico, Paul Walker", "abstract": "In this paper we describe the ARM Scalable Vector Extension (SVE). Several goals guided the design of the architecture. First was the need to extend the vector processing capability associated with the ARM AArch64 execution state to better address the compute requirements in domains such as high performance computing (HPC), data analytics, computer vision and machine learning. Second was the desire to introduce an extension that can scale across multiple implementations, both now and into the future, allowing CPU designers to choose the vector length most suitable for their power, performance and area targets. Finally, the architecture should avoid imposing a software development cost as the vector length changes and where possible reduce it by improving the reach of compiler auto-vectorization technologies.  We believe SVE achieves these goals. It allows implementations to choose a vector register length between 128 and 2048 bits. It supports a vector length agnostic programming model which allows code to run and scale automatically across all vector lengths without recompilation. Finally, it introduces several innovative features that begin to overcome some of the traditional barriers to auto-vectorization.", "booktitle": "IEEE Micro", "month": "March", "year": "2017", "volume": "37", "issue": "2", "isbn": "", "doi": "10.1109/MM.2017.35", "ar_shortname": "IEEE Micro", "ENTRYTYPE": "article", "ID": "journal/micro/sve2017", "file": "sve-ieee-micro-2017.pdf"}, {"title": "Trustworthy Specifications of ARM v8-A and v8-M System Level Architecture", "author": "Alastair Reid", "abstract": "Processor specifications are of critical importance for verifying programs, compilers, operating systems/hypervisors, and, of course, for verifying microprocessors themselves.  But to be useful, the scope of these specifications must be sufficient for the task, the specification must be applicable to processors of interest and the specification must be trustworthy.  This paper describes a 5 year project to change ARM's existing architecture specification process so that machine-readable, executable specifications can be automatically generated from the same materials used to generate ARM's conventional architecture documentation.  We have developed executable specifications of both ARM's A-class and M-class processor architectures that are complete enough and trustworthy enough that we have used them to formally verify ARM processors using bounded model checking.  In particular, our specifications include the semantics of the most security sensitive parts of the processor: the memory and register protection mechanisms and the exception mechanisms that trigger transitions between different modes.  Most importantly, we have applied a diverse set of methods including ARM's internal processor test suites to improve our trust in the specification using many other expressions of the architectural specification such as ARM's simulators, testsuites and processors to defend against common-mode failure.  In the process, we have also found bugs in all those artifacts: testing specifications is very much a two-way street.  While there have been previous specifications of ARM processors, their scope has excluded the system architecture, their applicability has excluded newer processors and M-class, and their trustworthiness has not been established as thoroughly.  Our focus has been on enabling the formal verification of ARM processors but, recognising the value of this specification for verifying software, we are currently preparing a public release of the machine-readable specification.", "booktitle": "Proceedings of Formal Methods in Computer-Aided Design, (FMCAD 2016)", "location": "Mountain View, CA, USA", "pages": "161-168", "month": "October", "year": "2016", "isbn": "978-0-9835678-6-8", "link": "https://alastairreid.github.io/papers/fmcad2016-trustworthy.pdf", "ENTRYTYPE": "article", "ID": "conf/fmcad/Reid16", "file": "fmcad2016-trustworthy.pdf", "slides": "fmcad2016-trustworthy-slides.pdf"}, {"title": "End-to-End Verification of ARM Processors with ISA-Formal", "booktitle": "Proceedings of the 2016 International Conference on Computer Aided Verification (CAV'16)", "abstract": "Despite 20+ years of research on processor verification, it remains hard to use formal verification techniques in commercial processor development.  There are two significant factors: scaling issues and return on investment.  The scaling issues include the size of modern processor specifications, the size/complexity of processor designs, the size of design/verification teams and the (non)availability of enough formal verification experts.  The return on investment issues include the need to start catching bugs early in development, the need to continue catching bugs throughout development, and the need to be able to reuse verification IP, tools and techniques across a wide range of design styles.  This paper describes how ARM has overcome these issues in our Instruction Set Architecture Formal Verification framework ``ISA-Formal.'' This is an end-to-end framework to detect bugs in the datapath, pipeline control and forwarding/stall logic of processors.  A key part of making the approach scale is use of a mechanical translation of ARM's Architecture Reference Manuals to Verilog allowing the use of commercial model-checkers.  ISA-Formal has proven especially effective at finding micro-architecture specific bugs involving complex sequences of instructions.  An essential feature of our work is that it is able to scale all the way from simple 3-stage microcontrollers, through superscalar in-order processors up to out-of-order processors.  We have applied this method to 8 different ARM processors spanning all stages of development up to release.  In all processors, this has found bugs that would have been hard for conventional simulation-based verification to find and ISA-Formal is now a key part of ARM's formal verification strategy.  To the best of our knowledge, this is the most broadly applicable formal verification technique for verifying processor pipeline control in mainstream commercial use.", "acceptance": "28", "editor": "S. Chaudhuri and A. Farzan", "series": "LNCS", "volume": "9780", "pages": "42-58", "publisher": "Springer Verlag", "month": "July", "year": "2016", "author": "Alastair Reid, Rick Chen, Anastasios Deligiannis, David Gilday, David Hoyes, Will Keen, Ashan Pathirane, Owen Shepherd, Peter Vrabel, Ali Zaidi", "journal": "CAV 2016, Part II, Lecture Notes in Computer Science", "location": "Toronto, Canada", "number": "9780", "doi": "10.1007/978-3-319-41540-6_3", "ar_shortname": "CAV 16", "isbn": "978-3-319-41539-0", "ENTRYTYPE": "article", "ID": "conf/cav/Reid16", "file": "cav2016_isa_formal.pdf", "slides": "ISA-Formal-CAV2016.pdf"}, {"author": "Matthias Boettcher, Bashir M. Al-Hashimi, Mbou Eyole, Giacomo Gabrielli, Alastair Reid", "abstract": "SIMD extensions have gained widespread acceptance in modern microprocessors as a way to exploit data-level parallelism in general-purpose cores. Popular SIMD architectures (e.g., Intel SSE/AVX) have evolved by adding support for wider registers and datapaths, and advanced features like indexed memory accesses, per-lane predication and inter-lane instructions, at the cost of additional silicon area and design complexity.  This paper evaluates the performance impact of such advanced features on a set of workloads considered hard to vectorize for traditional SIMD architectures. Their sensitivity to the most relevant design parameters (e.g. register/datapath width and L1 data cache configuration) is quantified and discussed.  We developed an ARMv7 NEON based ISA extension (ARGON), augmented a cycle accurate simulation framework for it, and derived a set of benchmarks from the Berkeley dwarfs. Our analyses demonstrate how ARGON can, depending on the structure of an algorithm, achieve speedups of 1.5x to 16x.", "editor": "Gerhard Fettweis and Wolfgang Nebel", "title": "Advanced SIMD: Extending the reach of contemporary SIMD architectures", "acceptance": "22", "booktitle": "Design, Automation & Test in Europe Conference & Exhibition, (DATE 2014)", "location": "Dresden, Germany", "pages": "1-4", "publisher": "European Design and Automation Association", "day": "24-28", "month": "March", "year": "2014", "doi": "10.7873/DATE.2014.037", "ar_shortname": "DATE 14", "ENTRYTYPE": "inproceedings", "ID": "DBLP:conf/date/BoettcherAEGR14", "file": "date2014_adv_simd.pdf"}, {"author": "Alastair D. Reid, Kriszti\u00e1n Flautner, Edmund Grimley-Evans, Yuan Lin", "title": "SoC-C: efficient programming abstractions for heterogeneous multicore systems on chip", "abstract": "The architectures of system-on-chip (SoC) platforms found in high-end consumer devices are getting more and more complex as designers strive to deliver increasingly compute-intensive applications on near-constant energy budgets.  Workloads running on these platforms require the exploitation of heterogeneous parallelism and increasingly irregular memory hierarchies.  The conventional approach to programming such hardware is very low-level but this yields software which is intimately and inseparably tied to the details of the platform it was originally designed for, limiting the software's portability, and, ultimately, the architectural choices available to designers of future platform generations.  The key insight of this paper is that many of the problems experienced in mapping applications onto SoC platforms come not from deciding how to map a program onto the hardware but from the need to restructure the program and the number of interdependencies introduced in the process of implementing those decisions.  We tackle this complexity with a set of language extensions which allows the programmer to introduce pipeline parallelism into sequential programs, manage distributed memories, and express the desired mapping of tasks to resources.  The compiler takes care of the complex, error-prone details required to implement that mapping.  We demonstrate the effectiveness of SoC-C and its compiler with a ``software defined radio'' example (the PHY layer of a Digital Video Broadcast receiver) achieving a 3.4x speedup on 4 cores.", "editor": "Erik R. Altman", "acceptance": "33", "booktitle": "Proceedings of the 2008 International Conference on Compilers, Architecture, and Synthesis for Embedded Systems (CASES 2008)", "location": "Atlanta, GA, USA", "pages": "95--104", "publisher": "ACM", "day": "19-24", "month": "October", "year": "2008", "doi": "10.1145/1450095.1450112", "ar_shortname": "CASES 08", "ENTRYTYPE": "inproceedings", "ID": "DBLP:conf/cases/ReidFGL08", "file": "cases2008-SoC-C.pdf"}, {"author": "Mark Woh, Yuan Lin, Sangwon Seo, Scott A. Mahlke, Trevor N. Mudge, Chaitali Chakrabarti, Richard Bruce, Danny Kershaw, Alastair Reid, Mladen Wilder, Kriszti\u00e1n Flautner", "title": "From SODA to scotch: The evolution of a wireless baseband processor", "abstract": "With the multitude of existing and upcoming wireless standards, it is becoming increasingly difficult for hardware-only baseband processing solutions to adapt to the rapidly changing wireless communication landscape. Software Defined Radio (SDR) promises to deliver a cost effective and flexible solution by implementing a wide variety of wireless protocols in software. In previous work, a fully programmable multicore architecture, SODA, was proposed that was able to meet the real-time requirements of 3G wireless protocols. SODA consists of one ARM control processor and four wide single instruction multiple data (SIMD) processing elements. Each processing element consists of a scalar and a wide 512-bit 32-lane SIMD datapath. A commercial prototype based on the SODA architecture, Ardbeg (named after a brand of Scotch Whisky), has been developed. In this paper, we present the architectural evolution of going from a research design to a commercial prototype, including the goals, trade-offs, and final design choices.  Ardbeg\u2019s redesign process can be grouped into the following three major areas: optimizing the wide SIMD datapath, providing long instruction word (LIW) support for SIMD operations, and adding application-specific hardware accelerators. Because SODA was originally designed with 180nm technology, the wide SIMD datapath is re-optimized in Ardbeg for 90nm technology. This includes re-evaluating the most efficient SIMD width, designing a wider SIMD shuffle network, and implementing faster SIMD arithmetic units. Ardbeg also provides modest LIW support by allowing two SIMD operations to issue in the same cycle. This LIW execution supports SDR algorithms\u2019 most common parallel SIMD execution patterns with minimal hardware overhead. A viable commercial SDR solution must be competitive with existing ASIC solutions. Therefore, algorithm-specific hardware is added for performance bottleneck algorithms while still maintaining enough flexibility to support multiple wireless protocols. The combination of these architectural improvements allows Ardbeg to achieve 1.5-7x speedup over SODA across multiple wireless algorithms while consuming less power.", "acceptance": "19", "booktitle": "41st Annual IEEE/ACM International Symposium on Microarchitecture (MICRO-41 2008)", "month": "November", "day": "8-12", "location": "Lake Como, Italy", "pages": "152--163", "publisher": "IEEE Computer Society", "year": "2008", "doi": "10.1109/MICRO.2008.4771787", "ar_shortname": "MICRO 08", "ENTRYTYPE": "inproceedings", "ID": "DBLP:conf/micro/WohLSMMCBKRWF08", "file": "mwoh-micro08.pdf"}, {"author": "Emre \u00d6zer, Alastair Reid, Stuart Biles", "title": "Low-cost Techniques for Reducing Branch Context Pollution in a Soft Realtime Embedded Multithreaded Processor", "abstract": "In this paper, we propose two low-cost and novel branch history buffer handling schemes aiming at skewing the branch prediction accuracy in favor of a real-time thread for a soft real-time embedded multithreaded processor. The processor core accommodates two running threads, one with the highest priority and the other thread is a background thread, and both threads share the branch predictor. The first scheme uses a 3-bit branch history buffer in which the highest priority thread uses the most significant 2 bits to change the prediction state while the background thread uses only the least significant 2 bits. The second scheme uses the shared 2-bit branch history buffer that implements integer updates for the highest priority thread but fractional updates for the background thread in order to achieve relatively higher prediction accuracy in the highest priority thread. The low cost nature of these two schemes, particularly in the second scheme, makes them attractive with moderate improvement in the performance of the highest priority thread.", "booktitle": "19th Symposium on Computer Architecture and High Performance Computing (SBAC-PAD 2007)", "day": "24-27", "month": "October", "location": "Gramado, RS, Brazil", "pages": "37--44", "publisher": "IEEE Computer Society", "year": "2007", "doi": "10.1109/SBAC-PAD.2007.15", "ar_shortname": "SBAC-PAD 07", "ENTRYTYPE": "inproceedings", "ID": "DBLP:conf/sbac-pad/OzerRB07", "file": "SBACPAD07.pdf"}, {"author": "Yuan Lin, Scott A. Mahlke, Trevor N. Mudge, Chaitali Chakrabarti, Alastair Reid, Kriszti\u00e1n Flautner", "title": "Design and Implementation of Turbo Decoders for Software Defined Radio", "abstract": "Software Defined Radio(SDR) is an emerging paradigm for wireless terminals, in which the physical layer of communication protocols is implemented in software rather than by ASICs. Many of the current and next generation wireless protocols include Turbo coding because of its superior performance. However, Turbo decoding is computationally intensive, and its low power implementations have typ- ically been in ASICs. This paper presents a case study of algorithm-architecture co-design of Turbo decoder for SDR. We present a programmable DSP architecture for SDR that includes a set of architectural features to accelerate Turbo decoder computations. We then present a parallel window scheduling for MAX-Log-MAP component decoder that matches well with the DSP architecture. Finally, we present a software implementation of Turbo decoder for W-CDMA on the DSP architecture and show that it achieves 2Mbps decoding throughput.", "booktitle": "Proceedings of the IEEE Workshop on Signal Processing Systems, (SiPS 2006)", "month": "October", "day": "2-4", "location": "Banff, Alberta, Canada", "pages": "22--27", "publisher": "IEEE", "year": "2006", "doi": "10.1109/SIPS.2006.352549", "ar_shortname": "SiPS 06", "ENTRYTYPE": "inproceedings", "ID": "DBLP:conf/sips/LinMMCRF06", "file": "lin-sips06.pdf"}, {"author": "Yuan Lin, Robert Mullenix, Mark Woh, Scott Mahlke, Trevor Mudge Alastair Reid, Kriszti\u00e1n Flautner", "title": "SPEX: A programming language for software defined radio", "booktitle": "Software Defined Radio Technical Conference and Product Exposition", "ar_shortname": "SDR 06", "abstract": "High-throughput, low-power Software Defined Radio(SDR) solutions require multi-core SIMD DSP processors to meet real-time performance requirements. Given the difficulty in programming traditional DSPs, these new multi-core signal processors provide even greater challenges for programmers and compilers. In this paper, we describe SPEX, a programming language which is aimed at narrowing the semantic gap between the description of complex SDR systems and their implementations. SPEX supports three different types of programming semantics, allowing SDR solutions to be developed with a divide-and-conquer approach. For DSP algorithm kernels, SPEX is able to support DSP arithmetics and first-class vector and matrix variables with sequential language semantics. From wireless protocol channels, it is able to support sequences of data-processing computations with dataflow language semantics. And for protocol systems, it is able to support real-time deadlines and concurrent executions with synchronous language semantics. The design choices are motivated by our experience implementing W-CDMA protocol on a reprogrammable substrate. In the paper, we also briefly explain SPEX\u2019s compilation strategies.", "year": "2006", "ENTRYTYPE": "article", "ID": "conf:SDR:LinMW2006", "file": "lin-sdr06.pdf"}, {"author": "John Regehr, Alastair Reid, Kirk Webb", "title": "Eliminating stack overflow by abstract interpretation", "abstract": "An important correctness criterion for software running on embedded microcontrollers is stack safety: a guarantee that the call stack does not overflow. Our first contribution is a method for statically guaranteeing stack safety of interrupt-driven embedded software using an approach based on context-sensitive dataflow analysis of object code. We have implemented a prototype stack analysis tool that targets software for Atmel AVR microcontrollers and tested it on embedded applications compiled from up to 30,000 lines of C. We experimentally validate the accuracy of the tool, which runs in under 10 sec on the largest programs that we tested. The second contribution of this paper is the development of two novel ways to reduce stack memory requirements of embedded software.", "journal": "ACM Transactions Embedded Computing Systems", "volume": "4", "number": "4", "pages": "751--778", "year": "2005", "doi": "10.1145/1113830.1113833", "ar_shortname": "ACM TECS 05", "ENTRYTYPE": "article", "ID": "DBLP:journals/tecs/RegehrRW05", "file": "p751-regehr.pdf"}, {"author": "John Regehr, Alastair Reid", "editor": "Shubu Mukherjee and Kathryn S. McKinley", "title": "HOIST: a system for automatically deriving static analyzers for embedded systems", "abstract": "Embedded software must meet conflicting requirements such as be- ing highly reliable, running on resource-constrained platforms, and being developed rapidly. Static program analysis can help meet all of these goals. People developing analyzers for embedded object code face a difficult problem: writing an abstract version of each instruction in the target architecture(s). This is currently done by hand, resulting in abstract operations that are both buggy and imprecise. We have developed Hoist: a novel system that solves these problems by automatically constructing abstract operations using a microprocessor (or simulator) as its own specification. With almost no input from a human, Hoist generates a collection of C functions that are ready to be linked into an abstract interpreter. We demonstrate that Hoist generates abstract operations that are correct, having been extensively tested, sufficiently fast, and substantially more precise than manually written abstract operations. Hoist is currently limited to eight-bit machines due to costs exponential in the word size of the target architecture. It is essential to be able to analyze software running on these small processors: they are important and ubiquitous, with many embedded and safety-critical systems being based on them.", "acceptance": "14", "booktitle": "Proceedings of the 11th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS 2004)", "location": "Boston, MA, USA", "month": "October", "day": "7-13", "pages": "133--143", "publisher": "ACM", "year": "2004", "doi": "10.1145/1024393.1024410", "ar_shortname": "ASPLOS 04", "ENTRYTYPE": "inproceedings", "ID": "DBLP:conf/asplos/RegehrR04", "file": "p021-regehr.pdf"}, {"title": "Lock inference for systems software", "author": "John Regehr, Alastair Reid", "abstract": "We have developed task scheduler logic (TSL) to automate reasoning about scheduling and concurrency in systems software. TSL can detect race conditions and other errors as well as supporting lock inference: the derivation of an appropriate lock implementation for each critical section in a system. Lock inference solves a number of problems in creating flexible, reliable, and efficient systems software. TSL is based on a notion of asymmetrical preemption relations and it exploits the hierarchical inheritance of scheduling properties that is common in systems software.", "booktitle": "Proceedings of the Second AOSD Workshop on Aspects, Components, and Patterns for Infrastructure Software (ACP4IS)", "ar_shortname": "ACP4IS 03", "ENTRYTYPE": "inproceedings", "ID": "tsl-acp4is2003", "file": "tsl-acp4is.pdf"}, {"author": "John Regehr, Alastair Reid, Kirk Webb", "editor": "Rajeev Alur and Insup Lee", "title": "Eliminating Stack Overflow by Abstract Interpretation", "abstract": "An important correctness criterion for software running on embedded microcontrollers is stack safety: a guarantee that the call stack does not overflow. We address two aspects of the problem of creating stack-safe embedded software that also makes efficient use of memory: statically bounding worst-case stack depth, and automatically reducing stack memory requirements. Our first contribution is a method for statically guaranteeing stack safety by performing whole-program analysis, using an approach based on context-sensitive abstract interpretation of machine code. Abstract interpretation permits our analysis to accurately model when interrupts are enabled and disabled, which is essential for accurately bounding the stack depth of typical embedded systems. We have implemented a stack analysis tool that targets Atmel AVR microcontrollers, and tested it on embedded applications compiled from up to 30,000 lines of C. We experimentally validate the accuracy of the tool, which runs in a few seconds on the largest programs that we tested. The second contribution of this paper is a novel framework for automatically reducing stack memory requirements. We show that goal-directed global function inlining can be used to reduce the stack memory requirements of component-based embedded software, on average, to 40% of the requirement of a system compiled without inlining, and to 68% of the requirement of a system compiled with aggressive whole-program inlining that is not directed towards reducing stack usage.", "booktitle": "Embedded Software, Third International Conference (EMSOFT 2003)", "location": "Philadelphia, PA, USA", "month": "October", "day": "13-15", "series": "Lecture Notes in Computer Science", "volume": "2855", "pages": "306--322", "publisher": "Springer", "year": "2003", "doi": "10.1007/978-3-540-45212-6_20", "ar_shortname": "EMSOFT 03", "ENTRYTYPE": "inproceedings", "ID": "DBLP:conf/emsoft/RegehrRW03", "file": "emsoft03-preprint.pdf"}, {"author": "John Regehr, Alastair Reid, Kirk Webb, Michael A. Parker, Jay Lepreau", "title": "Evolving real-time systems using hierarchical scheduling and concurrency analysis", "abstract": "We have developed a new way to look at real-time and embedded software: as a collection of execution environments created by a hierarchy of schedulers. Common schedulers include those that run interrupts, bottom-half handlers, threads, and events. We have created algorithms for deriving response times, scheduling overheads, and blocking terms for tasks in systems containing multiple execution environments. We have also created task scheduler logic, a formalism that permits checking systems for race conditions and other errors. Concurrency analysis of low-level software is challenging because there are typically several kinds of locks, such as thread mutexes and disabling interrupts, and groups of cooperating tasks may need to acquire some, all, or none of the available types of locks to create correct software. Our high level goal is to create systems that are evolvable: they are easier to modify in response to changing requirements than are systems created using traditional techniques. We have applied our approach to two case studies in evolving software for networked sensor nodes.", "booktitle": "Proceedings of the 24th IEEE Real-Time Systems Symposium (RTSS 2003)", "day": "3-5", "month": "December", "location": "Cancun, Mexico", "pages": "25--36", "publisher": "IEEE Computer Society", "year": "2003", "doi": "10.1109/REAL.2003.1253251", "ar_shortname": "RTSS 03", "ENTRYTYPE": "inproceedings", "ID": "DBLP:conf/rtss/RegehrRWPL03", "file": "rtss03-preprint.pdf"}, {"title": "The Haskell 98 Foreign Function Interface 1.0: An Addendum to the Haskell 98 Report", "author": "Manuel Chakravarty, Sigbjorn Finne, Fergus Henderson, Marcin Kowalczyk, Daan Leijen, Simon Marlow, Erik Meijer, Sven Panne, Simon Peyton Jones, Alastair Reid, Malcolm Wallace, Michael Weber", "year": "2003", "link": "https://www.cse.unsw.edu.au/~chak/haskell/ffi", "ENTRYTYPE": "article", "ID": "report:haskellffi:chakravarty2003", "file": "ffi.pdf"}, {"author": "Eric Eide, Alastair Reid, John Regehr, Jay Lepreau", "editor": "Will Tracz and Michal Young and Jeff Magee", "title": "Static and dynamic structure in design patterns", "acceptance": "15", "abstract": "Design patterns are a valuable mechanism for emphasizing structure, capturing design expertise, and facilitating restructuring of software systems. Patterns are typically applied in the context of an object-oriented language and are implemented so that the pattern participants correspond to object instances that are created and connected at run-time. This paper describes a complementary realization of design patterns, in which many pattern participants correspond to statically instantiated and connected components.Our approach separates the static parts of the software design from the dynamic parts of the system behavior. This separation makes the software design more amenable to analysis, thus enabling more effective and domain-specific detection of system design errors, prediction of run-time behavior, and more effective optimization. This technique is applicable to imperative, functional, and object-oriented languages: we have extended C, Scheme, and Java with our component model. In this paper, we illustrate our approach in the context of the OSKit, a collection of operating system components written in C.", "booktitle": "Proceedings of the 24th International Conference on Software Engineering, (ICSE 2002)", "day": "19-25", "month": "May", "location": "Orlando, Florida, USA", "pages": "208--218", "publisher": "ACM", "year": "2002", "doi": "10.1145/581339.581367", "ar_shortname": "ICSE 02", "ENTRYTYPE": "inproceedings", "ID": "DBLP:conf/icse/EideRRL02", "file": "knit-icse02.pdf"}, {"author": "Eric Eide, Alastair Reid, Matthew Flatt, Jay Lepreau", "title": "Aspect Weaving as Component Knitting: Separating Concerns with Knit", "abstract": "Knit is a new component specification and linking language. It was initially designed for low-level systems software, which requires especially flexible components with especially well-defined interfaces. For example, threads and virtual memory are typically implemented by components within the system, instead of being supplied by some execution environment. Consequently, components used to construct the system must expose interactions with threads and memory. The component composition tool must then check the resulting system for correctness, and weave the components together to achieve reasonable performance.  Component composition with Knit thus acts like aspect weaving: component interfaces determine the \u201cjoin points\u201d for weaving, while components (some of which may be automatically generated) implement aspects. Knit is not limited to the construction of low-level software, and to the degree that a set of components exposes fine-grained relationships, Knit provides the benefits of aspect-oriented programming within its component model.", "booktitle": "Workshop on Advanced Separation of Concerns in Software Engineering", "year": "2001", "ENTRYTYPE": "inproceedings", "ID": "EEide01Aspect", "file": "knit-icse01-wasc.pdf"}, {"author": "John Peterson, Paul Hudak, Alastair Reid, Gregory D. Hager", "editor": "I. V. Ramakrishnan", "title": "FVision: A Declarative Language for Visual Tracking", "abstract": "Functional programming languages are not generally associated with computationally intensive tasks such as computer vision. We show that a declarative programming language like Haskell is effective for describing complex visual tracking systems. We have taken an existing C++ library for computer vision, called XVision, and used it to build FVision (pronounced ``fission''), a library of Haskell types and functions that provides a high-level interface to the lower-level XVision code. Using functional abstractions, users of FVision can build and test new visual tracking systems rapidly and reliably. The use of Haskell does not degrade system performance: computations are dominated by low-level calculations expressed in C++ while the Haskell ``glue code'' has a negligible impact on performance.  FVision is built using functional reactive programming (FRP) to express interaction in a purely functional manner. The resulting system demonstrates the viability of mixed-language programming: visual tracking programs continue to spend most of their time executing low-level image-processing code, while Haskell's advanced features allow us to develop and test systems quickly and with confidence. In this paper, we demonstrate the use of Haskell and FRP to express many basic abstractions of visual tracking.", "booktitle": "Practical Aspects of Declarative Languages, Third International Symposium, (PADL 2001)", "location": "Las Vegas, Nevada, USA", "month": "March", "day": "11-12", "series": "Lecture Notes in Computer Science", "volume": "1990", "pages": "304--321", "publisher": "Springer", "year": "2001", "doi": "10.1007/3-540-45241-9_21", "ar_shortname": "PADL 01", "ENTRYTYPE": "inproceedings", "ID": "DBLP:conf/padl/PetersonHRH01", "file": "fvision-padl01-2.pdf"}, {"author": "Alastair Reid", "title": "The Hugs Graphics Library (Version 2.0)", "year": "2001", "ENTRYTYPE": "misc", "ID": "hugsgraphics2001", "file": "hugsgraphics.pdf"}, {"author": "Alastair Reid, Matthew Flatt, Leigh Stoller, Jay Lepreau, Eric Eide", "editor": "Michael B. Jones and M. Frans Kaashoek", "title": "Knit: Component Composition for Systems Software", "abstract": "Knit is a new component definition and linking language for systems code. Knit helps make C code more understandable and reusable by third parties, helps eliminate much of the performance overhead of componentization, detects subtle errors in component composition that cannot be caught with normal component type systems, and provides a foundation for developing future analyses over C-based components, such as cross-component optimization. The language is especially designed for use with component kits, where standard linking tools provide inadequate support for component configuration. In particular, we developed Knit for use with the OSKit, a large collection of components for building low-level systems. However, Knit is not OSKit-specific, and we have implemented parts of the Click modular router in terms of Knit components to illustrate the expressiveness and flexibility of our language. This paper provides an overview of the Knit language and its applications.", "booktitle": "4th Symposium on Operating System Design and Implementation (OSDI 2000)", "location": "San Diego, California, USA", "month": "October", "day": "23-25", "pages": "347--360", "publisher": "USENIX Association", "year": "2000", "link": "http://dl.acm.org/citation.cfm?id=1251253", "ENTRYTYPE": "inproceedings", "ID": "DBLP:conf/osdi/ReidFSLE00", "file": "knit-osdi00.pdf"}, {"author": "Alastair Reid, John Peterson, Gregory D. Hager, Paul Hudak", "editor": "Barry W. Boehm and David Garlan and Jeff Kramer", "title": "Prototyping Real-Time Vision Systems: An Experiment in DSL Design", "acceptance": "19", "abstract": "We describe the transformation of XVision, a large library of C++ code for real-time vision processing, into FVision (pronounced ``fission''), a fully-featured domain-specific language embedded in Haskell. The resulting prototype system substantiates the claims of increased modularity, effective code reuse, and rapid prototyping that characterize the DSL approach to system design. It also illustrates the need for judicious interface design: relegating computationally expensive tasks to XVision (pre-existing C++ components), and leaving modular compositional tasks to FVision (Haskell). At the same time, our experience demonstrates how Haskell's advanced language features (specifically parametric polymorphism, lazy evaluation, higher order functions and automatic storage reclamation) permit a rapid DSL design that is itself highly modular and easily modified. Overall, the resulting hybrid system exceeded our expectations: visual tracking programs continue to spend most of their time executing low level image-processing code, while Haskell's advanced features allow us to quickly develop and test small prototype systems within a matter of a few days and to develop realistic applications within a few weeks.", "booktitle": "Proceedings of the 1999 International Conference on Software Engineering (ICSE '99)", "location": "Los Angeles, CA, USA", "month": "May", "day": "16-22", "pages": "484--493", "publisher": "ACM", "year": "1999", "doi": "10.1109/icse.1999.841038", "ar_shortname": "ICSE 99", "ENTRYTYPE": "inproceedings", "ID": "DBLP:conf/icse/ReidPHH99", "file": "fvision-icse99-2.pdf"}, {"author": "Simon L. Peyton Jones, Alastair Reid, Fergus Henderson, C. A. R. Hoare, Simon Marlow", "editor": "Barbara G. Ryder and Benjamin G. Zorn", "title": "A Semantics for Imprecise Exceptions", "acceptance": "20", "abstract": "Some modern superscalar microprocessors provide only imprecise exceptions. That is, they do not guarantee to report the same exception that would be encountered by a straightforward sequential execution of the program. In exchange, they offer increased performance or decreased area (which amount to much the same thing).  This performance/precision tradeoff has not so far been much explored at the programming language level. In this paper we propose a design for imprecise exceptions in the lazy functional programming language Haskell. We discuss various simpler designs, and conclude that imprecision is essential if the language is still to enjoy its current rich algebra of transformations. We sketch a precise semantics for the language extended with exceptions.  From the functional programming point of view, the paper shows how to extend Haskell with exceptions without crippling the language or its compilers. From the point of view of the wider programming language community, we pose the question of whether precision and performance can be traded off in other languages too.", "booktitle": "Proceedings of the 1999 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI '99)", "location": "Atlanta, Georgia, USA", "month": "May", "day": "1-4", "pages": "25--36", "publisher": "ACM", "year": "1999", "doi": "10.1145/301618.301637", "ar_shortname": "PLDI 99", "ENTRYTYPE": "inproceedings", "ID": "DBLP:conf/pldi/JonesRHHM99", "file": "except.pdf"}, {"title": "Haskell 98: A non-strict, purely functional language", "author": "Simon Peyton Jones, Lennart Augustsson, Dave Barton, Brian Boutel, Warren Burton, Joseph Fasel, Kevin Hammond, Ralf Hinze, Paul Hudak, John Hughes, Thomas Johnsson, Mark Jones, John Launchbury, Erik Meijer, John Peterson, Alastair Reid, Colin Runciman, Philip Wadler", "year": "1999", "link": "https://www.haskell.org/definition/", "ENTRYTYPE": "misc", "ID": "report:haskell98report:jones1999", "file": "haskell98-report.pdf"}, {"title": "Standard Libraries for the Haskell 98 Programming Language", "author": "Simon Peyton Jones, Lennart Augustsson, Dave Barton, Brian Boutel, Warren Burton, Joseph Fasel, Kevin Hammond, Ralf Hinze, Paul Hudak, John Hughes, Thomas Johnsson, Mark Jones, John Launchbury, Erik Meijer, John Peterson, Alastair Reid, Colin Runciman, Philip Wadler", "year": "1999", "link": "https://www.haskell.org/definition/", "ENTRYTYPE": "misc", "ID": "report:haskell98libraries:jones1999", "file": "haskell98-library.pdf"}, {"author": "Alastair Reid", "editor": "Kevin Hammond and Antony J. T. Davie and Chris Clack", "title": "Putting the Spine Back in the Spineless Tagless G-Machine: An Implementation of Resumable Black-Holes", "abstract": "Interrupt handling is a tricky business in lazy functional languages: we have to make sure that thunks that are being evaluated can be halted and later restarted if and when they are required. This is a particular problem for implementations which use black-holing. Black-Holing deliberately makes it impossible to revert such thunks to their original state to avoid a serious space leak. Interactive Haskell implementations such as Hugs and hbi catch interrupts and avoid the problem by omitting or disabling black-holing. Batch mode Haskell implementations such as HBC and the Glasgow Haskell Compiler (GHC) avoid this problem by disabling black-holing or by providing no way to catch interrupts. This paper describes a modification to GHC\u2019s abstract machine (the Spineless Tagless G-Machine) which simultaneously supports both interrupts and black-holing.", "booktitle": "Implementation of Functional Languages, 10th International Workshop, (IFL'98) Selected Papers", "location": "London, UK", "month": "September", "day": "9-11", "series": "Lecture Notes in Computer Science", "volume": "1595", "pages": "186--199", "publisher": "Springer", "year": "1998", "doi": "10.1007/3-540-48515-5_12", "ar_shortname": "IFL 98", "ENTRYTYPE": "inproceedings", "ID": "DBLP:conf/ifl/Reid98", "file": "spine-ifl98.pdf"}, {"author": "Alastair Reid", "title": "Handling Exceptions in Haskell", "abstract": "Using a language without exception handling is like driving a car with no brakes and no seatbelt --- things work fine until something goes wrong. You also learn to drive rather carefully. This paper describes an exception handling extension to the Haskell lazy functional language. The implementation turned out to be very easy but we had problems finding a viable semantics for our system. The resulting semantics is a compromise between theoretical beauty and practical utility.", "booktitle": "Yale University Research Report YALE/DCS/RR-1178", "location": "New Haven, CT, USA", "month": "August", "year": "1998", "ENTRYTYPE": "inproceedings", "ID": "Reid98exceptions", "file": "exceptions98.pdf"}, {"author": "Alastair Reid, John Peterson", "title": "Designing the Standard Haskell Libraries", "year": "1998", "ENTRYTYPE": "misc", "ID": "Reid98haskelllibraries", "file": "libraries.pdf"}, {"author": "Simon Peyton Jones, Thomas Nordin, Alastair Reid", "title": "Green Card: a foreign-language interface for Haskell", "booktitle": "Proceedings of the Haskell Workshop", "location": "Amsterdam, Netherlands", "month": "June", "ENTRYTYPE": "inproceedings", "ID": "greencard1997", "file": "green-card.pdf"}, {"author": "John Peterson, Alastair Reid", "title": "Adding Records to Haskell", "booktitle": "Proceedings of the Haskell Workshop 1995, Yale University Research Report YALE/DCS/RR-1075", "location": "Portland, Oregon, USA", "year": "1995", "link": "https://www.haskell.org/haskell-workshop/1995/HW1995-Proceedings.pdf", "ENTRYTYPE": "inproceedings", "ID": "Peterson95addingrecords", "file": "records.pdf"}, {"author": "Alastair Reid, John Peterson", "title": "A Proposal for the Standard Haskell Libraries", "booktitle": "Proceedings of the Haskell Workshop 1995, Yale University Research Report YALE/DCS/RR-1075", "location": "Portland, Oregon, USA", "year": "1995", "page": "69-81", "link": "https://www.haskell.org/haskell-workshop/1995/HW1995-Proceedings.pdf", "ENTRYTYPE": "inproceedings", "ID": "Reid95haskelllibraries", "file": "HW1995-Proceedings.pdf"}, {"author": "Alastair Reid", "title": "Malloc Pointers and Stable Pointers: Improving Haskell's Foreign Language Interface", "booktitle": "In Glasgow Functional Programming Workshop Draft Proceedings", "year": "1994", "ENTRYTYPE": "inproceedings", "ID": "Reid94mallocpointers", "file": "malloc.pdf"}, {"author": "Alastair Reid, Satnam Singh", "editor": "John T. O'Donnell and Kevin Hammond", "title": "Implementing Fudgets with Standard Widget Sets", "abstract": "Carlsson and Hallgren describe the implementation of a set of \"functional widgets\" (Fudgets): components for programming graphical user interfaces under the X window system using the non-strict functional programming language Haskell. We describe an alternative implementation based on existing widget sets (currently Openlook and Motif). Our purpose is twofold: to show that the Fudgets approach can be applied to existing widget sets; and to discuss problems experienced with Fudgets during an industrial case study.", "booktitle": "Functional Programming, Glasgow 1993: Proceedings of the 1993 Glasgow Workshop on Functional Programming, location = Ayr, Scotland, day = 5-7, month = July, year=\"1993", "publisher": "Springer London", "address": "London", "pages": "222--235", "isbn": "978-1-4471-3236-3", "doi": "10.1007/978-1-4471-3236-3_18", "ar_shortname": "GFP 93", "ENTRYTYPE": "inbook", "ID": "Reid1993"}, {"author": "Alastair Reid", "title": "A Precise Semantics for Ultraloose Specifications", "abstract": "All formal specifiers face the danger of overspecification: accidentally writing an overly restrictive specification. This problem is particularly acute for axiomatic specifications because it is so easy to write axioms that hold for some of the intended implementations but not for all of them (or, rather, it is hard not to write overly strong axioms).  One of the best developed ways of recovering some of these implementations which do not literally satisfy the specification is to apply a ``behavioural abstraction operator'' to a specification: adding in those implementations which have the same ``behaviour'' as an implementation which does satisfy the specification.  In two recent papers, Broy and Wirsing propose an alternative (and apparently simpler) approach which they call ``ultraloose specification.''  This approach is based on a particular style of writing axioms which avoids certain forms of overspecification.  An important, unanswered question is ``How does the ultraloose approach relate to other solutions?'' The major achievement of this thesis is a proof that the ultraloose approach is semantically equivalent to the use of the ``behavioural abstraction operator.''  This result is rather surprising in the light of a result by Schoett which seems to say that such a result is impossible.", "school": "Glasgow School of Computing Science", "location": "Glasgow, Scotland", "ar_shortname": "M.Sc.", "year": "1993", "ENTRYTYPE": "mastersthesis", "ID": "ReidThesis93", "file": "ReidThesis93.pdf"}, {"author": "Alastair Reid", "editor": "Kei Davis and John Hughes", "title": "Designing Data Structures", "abstract": "The design (as opposed to the choice and use) of data structures has been the subject of relatively little study in the context of formal methods. In this paper, we introduce our ideas on how data structures are designed.", "booktitle": "Functional Programming, Proceedings of the 1989 Glasgow Workshop", "day": "21-23", "month": "August", "location": "Fraserburgh, Scotland, UK", "series": "Workshops in Computing", "pages": "170--181", "publisher": "Springer", "year": "1989", "ENTRYTYPE": "inproceedings", "ID": "DBLP:conf/fp/Reid89", "file": "designing.pdf"}]
